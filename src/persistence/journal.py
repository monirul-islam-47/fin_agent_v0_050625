"""Trade Journal - Persistent storage for all trade recommendations and outcomes.

This module creates and manages a SQLite database to store:
- All trade signals generated by the system
- Trade execution details (if manually entered)
- Performance outcomes
"""

import sqlite3
import json
import asyncio
from dataclasses import asdict
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from contextlib import contextmanager

from src.utils.logger import setup_logger
from src.orchestration.event_bus import EventBus
from src.orchestration.events import TradeSignal, EventType
from src.domain.planner import TradePlan

logger = setup_logger(__name__)


class TradeJournal:
    """Manages persistent storage of trade recommendations and outcomes."""
    
    def __init__(self, db_path: str = "data/trades.db"):
        """Initialize Trade Journal.
        
        Args:
            db_path: Path to SQLite database file
        """
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Create database schema
        self._init_database()
        
        # Event bus subscription
        self._event_bus: Optional[EventBus] = None
        
    def _init_database(self):
        """Initialize database schema."""
        with self._get_connection() as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS trades (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp DATETIME NOT NULL,
                    symbol TEXT NOT NULL,
                    score REAL NOT NULL,
                    direction TEXT NOT NULL,
                    entry_strategy TEXT NOT NULL,
                    entry_price REAL NOT NULL,
                    stop_loss REAL NOT NULL,
                    stop_loss_percent REAL NOT NULL,
                    target_price REAL NOT NULL,
                    target_percent REAL NOT NULL,
                    position_size_eur REAL NOT NULL,
                    position_size_shares INTEGER NOT NULL,
                    max_risk_eur REAL NOT NULL,
                    risk_reward_ratio REAL NOT NULL,
                    win_probability REAL NOT NULL,
                    
                    -- Execution details (nullable until trade is taken)
                    actual_entry_price REAL,
                    actual_entry_time DATETIME,
                    actual_exit_price REAL,
                    actual_exit_time DATETIME,
                    pnl_eur REAL,
                    pnl_percent REAL,
                    status TEXT DEFAULT 'pending',  -- pending, executed, closed, cancelled
                    
                    -- Metadata
                    factors TEXT NOT NULL,  -- JSON string
                    notes TEXT,  -- JSON array
                    created_at DATETIME NOT NULL
                )
            """)
            
            # Create indices for common queries
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol ON trades(symbol)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_timestamp ON trades(timestamp)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_status ON trades(status)")
            
            conn.commit()
            
        logger.info(f"Trade journal database initialized at {self.db_path}")
        
    @contextmanager
    def _get_connection(self):
        """Get database connection context manager."""
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()
            
    async def subscribe_to_events(self, event_bus: EventBus):
        """Subscribe to trade signal events.
        
        Args:
            event_bus: Event bus to subscribe to
        """
        self._event_bus = event_bus
        await event_bus.subscribe(EventType.TRADE_SIGNAL, self._handle_trade_signal)
        logger.info("Trade journal subscribed to TRADE_SIGNAL events")
        
    async def _handle_trade_signal(self, event: TradeSignal):
        """Handle incoming trade signal event.
        
        Args:
            event: Trade signal event
        """
        try:
            # Record the trade plan
            trade_id = self.record_trade(
                trade_plan=event.trade_plan,
                factors=event.factors,
                timestamp=event.timestamp
            )
            logger.info(f"Recorded trade signal for {event.trade_plan.symbol} with ID {trade_id}")
        except Exception as e:
            logger.error(f"Failed to record trade signal: {e}")
            
    def record_trade(
        self,
        trade_plan: TradePlan,
        factors: Dict[str, float],
        timestamp: Optional[datetime] = None
    ) -> int:
        """Record a new trade recommendation.
        
        Args:
            trade_plan: Trade plan from planner
            factors: Factor scores that led to this trade
            timestamp: Optional timestamp (defaults to now)
            
        Returns:
            Trade ID
        """
        if timestamp is None:
            timestamp = datetime.now()
            
        with self._get_connection() as conn:
            cursor = conn.execute("""
                INSERT INTO trades (
                    timestamp, symbol, score, direction,
                    entry_strategy, entry_price, stop_loss, stop_loss_percent,
                    target_price, target_percent, position_size_eur,
                    position_size_shares, max_risk_eur, risk_reward_ratio,
                    win_probability, factors, notes, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                timestamp,
                trade_plan.symbol,
                trade_plan.score,
                trade_plan.direction,
                trade_plan.entry_strategy.value,
                trade_plan.entry_price,
                trade_plan.stop_loss,
                trade_plan.stop_loss_percent,
                trade_plan.target_price,
                trade_plan.target_percent,
                trade_plan.position_size_eur,
                trade_plan.position_size_shares,
                trade_plan.max_risk_eur,
                trade_plan.risk_reward_ratio,
                trade_plan.win_probability,
                json.dumps(factors),
                json.dumps(trade_plan.notes),
                trade_plan.created_at
            ))
            conn.commit()
            
            trade_id = cursor.lastrowid
            logger.info(f"Recorded trade {trade_id} for {trade_plan.symbol}")
            return trade_id
            
    def update_execution(
        self,
        trade_id: int,
        actual_entry_price: float,
        actual_entry_time: datetime,
        status: str = "executed"
    ):
        """Update trade with execution details.
        
        Args:
            trade_id: Trade ID to update
            actual_entry_price: Actual entry price achieved
            actual_entry_time: Actual entry time
            status: Trade status
        """
        with self._get_connection() as conn:
            conn.execute("""
                UPDATE trades
                SET actual_entry_price = ?,
                    actual_entry_time = ?,
                    status = ?
                WHERE id = ?
            """, (actual_entry_price, actual_entry_time, status, trade_id))
            conn.commit()
            
        logger.info(f"Updated trade {trade_id} with execution details")
        
    def close_trade(
        self,
        trade_id: int,
        actual_exit_price: float,
        actual_exit_time: datetime
    ):
        """Close a trade with exit details and calculate P&L.
        
        Args:
            trade_id: Trade ID to close
            actual_exit_price: Exit price achieved
            actual_exit_time: Exit time
        """
        with self._get_connection() as conn:
            # Get trade details
            cursor = conn.execute("""
                SELECT actual_entry_price, position_size_shares, direction
                FROM trades
                WHERE id = ?
            """, (trade_id,))
            
            row = cursor.fetchone()
            if not row or row['actual_entry_price'] is None:
                raise ValueError(f"Trade {trade_id} not found or not executed")
                
            entry_price = row['actual_entry_price']
            shares = row['position_size_shares']
            direction = row['direction']
            
            # Calculate P&L
            if direction == "long":
                pnl_eur = (actual_exit_price - entry_price) * shares
                pnl_percent = ((actual_exit_price - entry_price) / entry_price) * 100
            else:
                pnl_eur = (entry_price - actual_exit_price) * shares
                pnl_percent = ((entry_price - actual_exit_price) / entry_price) * 100
                
            # Update trade
            conn.execute("""
                UPDATE trades
                SET actual_exit_price = ?,
                    actual_exit_time = ?,
                    pnl_eur = ?,
                    pnl_percent = ?,
                    status = 'closed'
                WHERE id = ?
            """, (actual_exit_price, actual_exit_time, pnl_eur, pnl_percent, trade_id))
            conn.commit()
            
        logger.info(f"Closed trade {trade_id} with P&L: â‚¬{pnl_eur:.2f} ({pnl_percent:.1f}%)")
        
    def get_recent_trades(
        self,
        limit: int = 20,
        status: Optional[str] = None,
        symbol: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Get recent trades with optional filtering.
        
        Args:
            limit: Maximum number of trades to return
            status: Optional status filter
            symbol: Optional symbol filter
            
        Returns:
            List of trade records
        """
        query = "SELECT * FROM trades WHERE 1=1"
        params = []
        
        if status:
            query += " AND status = ?"
            params.append(status)
            
        if symbol:
            query += " AND symbol = ?"
            params.append(symbol)
            
        query += " ORDER BY timestamp DESC LIMIT ?"
        params.append(limit)
        
        with self._get_connection() as conn:
            cursor = conn.execute(query, params)
            trades = []
            
            for row in cursor:
                trade = dict(row)
                # Parse JSON fields
                trade['factors'] = json.loads(trade['factors'])
                trade['notes'] = json.loads(trade['notes']) if trade['notes'] else []
                trades.append(trade)
                
        return trades
        
    def get_trades_by_date_range(
        self,
        start_date: datetime,
        end_date: datetime,
        status: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Get trades within a date range.
        
        Args:
            start_date: Start date
            end_date: End date
            status: Optional status filter
            
        Returns:
            List of trade records
        """
        query = "SELECT * FROM trades WHERE timestamp BETWEEN ? AND ?"
        params = [start_date, end_date]
        
        if status:
            query += " AND status = ?"
            params.append(status)
            
        query += " ORDER BY timestamp ASC"
        
        with self._get_connection() as conn:
            cursor = conn.execute(query, params)
            trades = []
            
            for row in cursor:
                trade = dict(row)
                trade['factors'] = json.loads(trade['factors'])
                trade['notes'] = json.loads(trade['notes']) if trade['notes'] else []
                trades.append(trade)
                
        return trades
        
    def get_performance_summary(self) -> Dict[str, Any]:
        """Get overall performance summary.
        
        Returns:
            Dictionary with performance metrics
        """
        with self._get_connection() as conn:
            # Get closed trades summary
            cursor = conn.execute("""
                SELECT 
                    COUNT(*) as total_trades,
                    COUNT(CASE WHEN status = 'closed' THEN 1 END) as closed_trades,
                    COUNT(CASE WHEN pnl_eur > 0 THEN 1 END) as winning_trades,
                    COUNT(CASE WHEN pnl_eur < 0 THEN 1 END) as losing_trades,
                    COALESCE(SUM(pnl_eur), 0) as total_pnl,
                    COALESCE(AVG(pnl_percent), 0) as avg_return_percent,
                    COALESCE(MAX(pnl_eur), 0) as best_trade,
                    COALESCE(MIN(pnl_eur), 0) as worst_trade
                FROM trades
            """)
            
            summary = dict(cursor.fetchone())
            
            # Calculate win rate
            if summary['closed_trades'] > 0:
                summary['win_rate'] = summary['winning_trades'] / summary['closed_trades']
            else:
                summary['win_rate'] = 0.0
                
        return summary
        
    def export_to_csv(self, filepath: str, start_date: Optional[datetime] = None,
                     end_date: Optional[datetime] = None):
        """Export trades to CSV file.
        
        Args:
            filepath: Path to save CSV
            start_date: Optional start date filter
            end_date: Optional end date filter
        """
        import csv
        
        # Get trades
        if start_date and end_date:
            trades = self.get_trades_by_date_range(start_date, end_date)
        else:
            trades = self.get_recent_trades(limit=10000)  # Large limit for export
            
        # Write to CSV
        if trades:
            with open(filepath, 'w', newline='') as f:
                # Get all unique keys across all trades
                all_keys = set()
                for trade in trades:
                    all_keys.update(trade.keys())
                    
                # Remove complex fields
                all_keys.discard('factors')
                all_keys.discard('notes')
                
                # Write header
                fieldnames = sorted(all_keys)
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
                
                # Write trades
                for trade in trades:
                    # Create row without complex fields
                    row = {k: v for k, v in trade.items() if k in fieldnames}
                    writer.writerow(row)
                    
            logger.info(f"Exported {len(trades)} trades to {filepath}")
        else:
            logger.warning("No trades to export")